import requests
import socket
import json
import sys
from datetime import datetime, timezone
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor

DATA_DIR = Path(__file__).with_name("data")
SWITCH_CONTROL_HTML = Path(__file__).with_name("Tasmota_switch_control.html")


def _ensure_utf8_stdout():
    try:
        sys.stdout.reconfigure(encoding="utf-8")
    except Exception:
        pass


def _now_iso_local():
    return datetime.now(timezone.utc).astimezone().isoformat(timespec="seconds")


def _safe_float(value):
    if value is None:
        return None
    if isinstance(value, (int, float)):
        return float(value)
    if isinstance(value, str):
        value = value.strip()
        if not value or value.upper() == "N/A":
            return None
    try:
        return float(value)
    except (TypeError, ValueError):
        return None


def _normalize_mac(mac):
    if not mac:
        return None
    mac = str(mac).strip()
    if not mac or mac.upper() == "N/A":
        return None
    return mac.upper()


def _safe_filename(stem: str, fallback: str = "device"):
    """Make a Windows-safe filename stem (no path separators, no weird chars)."""
    if stem is None:
        stem = ""
    stem = str(stem).strip()
    if not stem:
        stem = fallback
    out = []
    for ch in stem:
        if ch.isalnum() or ch in ("-", "_", "."):
            out.append(ch)
        elif ch.isspace():
            out.append("_")
        else:
            out.append("_")
    cleaned = "".join(out).strip("._ ")
    return cleaned or fallback


def _rewrite_switch_control_html(devices, html_path: Path = SWITCH_CONTROL_HTML):
    """Rewrite the hardcoded switch-control HTML to match discovered devices.

    Updates:
    - Button count (by changing DEVICES array length)
    - Button labels (hostname)
    - URLs (derived from IP in the HTML logic)
    """
    if not devices:
        return False

    marker_begin = "// BEGIN AUTOGENERATED DEVICES"
    marker_end = "// END AUTOGENERATED DEVICES"

    lines = [
        marker_begin,
        "    // This block can be overwritten by tasmota_scan.py after a scan.",
        "    const DEVICES = [",
    ]

    for d in devices:
        ip = d.get("ip")
        hostname = d.get("hostname")
        if not ip:
            continue
        ip_js = json.dumps(str(ip))
        host_js = json.dumps(str(hostname)) if hostname else "null"
        lines.append(f"      {{ ip: {ip_js}, hostname: {host_js} }},")

    lines += [
        "    ];",
        marker_end,
    ]
    new_block = "\n".join(lines)

    try:
        content = html_path.read_text(encoding="utf-8")
    except OSError:
        return False

    start = content.find(marker_begin)
    end = content.find(marker_end)
    if start == -1 or end == -1 or end < start:
        print(f"‚ö†Ô∏è  Cannot auto-update switch UI (markers missing): {html_path}")
        return False

    end += len(marker_end)
    updated = content[:start] + new_block + content[end:]

    try:
        html_path.write_text(updated, encoding="utf-8")
        print(f"üß© Switch UI updated: {html_path}")
        return True
    except OSError:
        return False


def _clean_str(value, default="N/A"):
    if value is None:
        return default
    text = str(value)
    if not text or text.upper() == "N/A":
        return default
    return text.replace("\r", " ").replace("\n", " ")


def _parse_iso_ts(value):
    if not value:
        return None
    try:
        return datetime.fromisoformat(str(value))
    except ValueError:
        return None


def generate_cost_plot_per_device(data_dir: Path, output_png: Path):
    """Create one figure: cost (EUR) over time, one line per device."""
    try:
        import matplotlib.pyplot as plt
        import matplotlib.dates as mdates
    except ImportError:
        print("‚ö†Ô∏è  matplotlib is not installed. Install with: pip install -r requirements.txt")
        return None

    if not data_dir.exists():
        print(f"‚ö†Ô∏è  data folder not found: {data_dir}")
        return None

    series_by_device = []  # list of (label, times[], eur[])

    for path in sorted(data_dir.glob("*.json")):
        try:
            with path.open("r", encoding="utf-8") as f:
                device_log = json.load(f)
        except (OSError, json.JSONDecodeError):
            continue

        dev = device_log.get("device") or {}
        label = dev.get("hostname") or dev.get("name") or path.stem
        label = _clean_str(label, default=path.stem)

        baseline_kwh = _safe_float(dev.get("baseline_total_kwh"))
        entries = device_log.get("entries") or []
        points = []

        for e in entries:
            ts = _parse_iso_ts(e.get("ts"))
            if ts is None:
                continue

            cost_since = _safe_float(e.get("cost_since_first_seen_eur"))
            if cost_since is None:
                total_kwh = _safe_float(e.get("total_kwh"))
                price = _safe_float(e.get("price_eur_per_kwh"))
                if baseline_kwh is not None and total_kwh is not None and price is not None:
                    cost_since = max(total_kwh - baseline_kwh, 0.0) * price

            if cost_since is None:
                continue

            points.append((ts, cost_since))

        if not points:
            continue

        points.sort(key=lambda x: x[0])
        times = [p[0] for p in points]
        eur = [p[1] for p in points]
        series_by_device.append((label, times, eur))

    if not series_by_device:
        print(f"‚ö†Ô∏è  No plottable cost data in: {data_dir}")
        return None

    fig, ax = plt.subplots(figsize=(12, 6))
    for label, times, eur in series_by_device:
        ax.plot(times, eur, linewidth=2, label=label)

    ax.set_ylabel("EUR")
    ax.set_title("Tasmota: Kosten (EUR) √ºber Zeit")
    ax.grid(True, which="both", axis="both", alpha=0.25)
    ax.xaxis.set_major_formatter(mdates.DateFormatter("%Y-%m-%d %H:%M"))
    fig.autofmt_xdate(rotation=30, ha="right")
    ax.legend(loc="upper left")

    output_png.parent.mkdir(parents=True, exist_ok=True)
    fig.tight_layout()
    fig.savefig(output_png, dpi=150)
    print(f"üìà Plot saved: {output_png}")

    try:
        plt.show()
    except Exception:
        pass
    return output_png


def load_device_log(path: Path):
    """Load a per-device log file."""
    if not path.exists():
        return {
            "schema_version": 1,
            "price_eur_per_kwh_default": 0.329,
            "device": {},
            "entries": [],
        }
    try:
        with path.open("r", encoding="utf-8") as f:
            data = json.load(f)
    except (OSError, json.JSONDecodeError):
        data = {
            "schema_version": 1,
            "price_eur_per_kwh_default": 0.329,
            "device": {},
            "entries": [],
        }

    data.setdefault("schema_version", 1)
    data.setdefault("price_eur_per_kwh_default", 0.329)
    data.setdefault("device", {})
    data.setdefault("entries", [])
    return data


def save_device_log(path: Path, data):
    try:
        path.parent.mkdir(parents=True, exist_ok=True)
        with path.open("w", encoding="utf-8") as f:
            json.dump(data, f, ensure_ascii=False, indent=2)
            f.write("\n")
    except OSError:
        pass


def log_device_snapshot(device_log, device_info, energy_data, preis_prokw, state_data=None):
    ts = _now_iso_local()

    state_data = state_data or {}
    wifi_state = state_data.get("Wifi") or {}

    mac = _normalize_mac(device_info.get("mac"))
    dev = device_log.setdefault("device", {})
    dev.setdefault("first_seen", ts)
    dev["last_seen"] = ts

    dev["mac"] = mac or dev.get("mac")
    dev["name"] = device_info.get("name", dev.get("name"))
    dev["module"] = device_info.get("module", dev.get("module"))
    dev["version"] = device_info.get("version", dev.get("version"))

    hostname = state_data.get("Hostname")
    if hostname:
        dev["hostname"] = hostname

    ip = device_info.get("ip")
    if ip:
        ip_history = dev.setdefault("ip_history", [])
        if ip not in ip_history:
            ip_history.append(ip)

    total_kwh = _safe_float(energy_data.get("total"))
    today_kwh = _safe_float(energy_data.get("today"))
    yesterday_kwh = _safe_float(energy_data.get("yesterday"))
    power_w = _safe_float(energy_data.get("power"))
    voltage_v = _safe_float(energy_data.get("voltage"))
    current_a = _safe_float(energy_data.get("current"))

    power_state = state_data.get("POWER")
    wifi_rssi_percent = _safe_float(wifi_state.get("RSSI"))
    wifi_signal_dbm = _safe_float(wifi_state.get("Signal"))
    uptime = state_data.get("Uptime")
    uptime_sec = _safe_float(state_data.get("UptimeSec"))
    device_time = state_data.get("Time")

    if dev.get("baseline_total_kwh") is None and total_kwh is not None:
        dev["baseline_total_kwh"] = total_kwh
        dev["baseline_set_at"] = ts

    baseline_kwh = _safe_float(dev.get("baseline_total_kwh"))

    cost_total_eur = (total_kwh * preis_prokw) if total_kwh is not None else None
    cost_today_eur = (today_kwh * preis_prokw) if today_kwh is not None else None
    cost_yesterday_eur = (yesterday_kwh * preis_prokw) if yesterday_kwh is not None else None
    if baseline_kwh is not None and total_kwh is not None:
        cost_since_first_seen_eur = max(total_kwh - baseline_kwh, 0.0) * preis_prokw
    else:
        cost_since_first_seen_eur = None

    entry = {
        "ts": ts,
        "device_time": device_time,
        "ip": ip,
        "hostname": state_data.get("Hostname"),
        "name": device_info.get("name"),
        "price_eur_per_kwh": preis_prokw,
        "power_state": power_state,
        "wifi_rssi_percent": wifi_rssi_percent,
        "wifi_signal_dbm": wifi_signal_dbm,
        "uptime": uptime,
        "uptime_sec": uptime_sec,
        "total_kwh": total_kwh,
        "today_kwh": today_kwh,
        "yesterday_kwh": yesterday_kwh,
        "power_w": power_w,
        "voltage_v": voltage_v,
        "current_a": current_a,
        "cost_total_eur": cost_total_eur,
        "cost_today_eur": cost_today_eur,
        "cost_yesterday_eur": cost_yesterday_eur,
        "cost_since_first_seen_eur": cost_since_first_seen_eur
    }

    device_log.setdefault("entries", []).append(entry)
    return entry

def get_local_network():
    hostname = socket.gethostname()
    local_ip = socket.gethostbyname(hostname)
    ip_parts = local_ip.split('.')
    network_prefix = f"{ip_parts[0]}.{ip_parts[1]}.{ip_parts[2]}."
    return network_prefix

def check_tasmota(ip):
    url = f"http://{ip}/"
    try:
        response = requests.get(url, timeout=1)
        if "Tasmota" in response.text:
            print(f"üîç Found Tasmota device: http://{ip}")
            return ip
    except requests.RequestException:
        pass
    return None


def get_state_data(ip):
    """Fetch current device state (POWER/Wifi/Uptime)."""
    url = f"http://{ip}/cm?cmnd=State"
    try:
        response = requests.get(url, timeout=2)
        response.raise_for_status()
        return response.json()
    except (requests.RequestException, ValueError):
        return {}

def get_device_info(ip):
    """Fetch device information."""
    info_url = f"http://{ip}/cm?cmnd=Status%200"
    status_url = f"http://{ip}/cm?cmnd=Status%205"
    wifi_url = f"http://{ip}/cm?cmnd=Status%2011"

    device_info = {
        'name': f"Unknown ({ip})",
        'version': 'N/A',
        'uptime': 'N/A',
        'wifi_ssid': 'N/A',
        'wifi_rssi': 'N/A',
        'ip': ip,
        'mac': 'N/A',
        'module': 'N/A'
    }

    try:
        # Base information
        response = requests.get(info_url, timeout=2)
        data = response.json()
        status = data.get("Status", {})

        device_info['name'] = status.get("DeviceName", f"Unknown ({ip})")
        friendly_name = status.get("FriendlyName", [""])[0]
        if friendly_name:
            device_info['name'] = friendly_name

        device_info['version'] = status.get("Version", 'N/A')
        device_info['module'] = status.get("Module", 'N/A')

        # Network information
        net_response = requests.get(status_url, timeout=2)
        net_data = net_response.json()
        net_status = net_data.get("StatusNET", {})

        device_info['mac'] = net_status.get("Mac", 'N/A')

        # WiFi information
        wifi_response = requests.get(wifi_url, timeout=2)
        wifi_data = wifi_response.json()
        wifi_status = wifi_data.get("StatusSTS", {})

        device_info['wifi_ssid'] = wifi_status.get("Wifi", {}).get("SSId", 'N/A')
        device_info['wifi_rssi'] = wifi_status.get("Wifi", {}).get("RSSI", 'N/A')
        device_info['uptime'] = wifi_status.get("Uptime", 'N/A')

    except requests.RequestException:
        pass

    return device_info

def get_energy_data(ip):
    """Fetch energy telemetry."""
    url = f"http://{ip}/cm?cmnd=Status%208"
    energy_data = {
        'total': 'N/A',
        'power': 'N/A',
        'voltage': 'N/A',
        'current': 'N/A',
        'today': 'N/A',
        'yesterday': 'N/A'
    }

    try:
        response = requests.get(url, timeout=2)
        data = response.json()
        energy = data.get("StatusSNS", {}).get("ENERGY", {})

        energy_data['total'] = energy.get("Total", "N/A")
        energy_data['power'] = energy.get("Power", "N/A")
        energy_data['voltage'] = energy.get("Voltage", "N/A")
        energy_data['current'] = energy.get("Current", "N/A")
        energy_data['today'] = energy.get("Today", "N/A")
        energy_data['yesterday'] = energy.get("Yesterday", "N/A")

    except requests.RequestException:
        pass

    return energy_data

def print_device_details(device_info, energy_data, state_data=None, preis_prokw=0.329):
    """Print detailed device information."""
    state_data = state_data or {}
    wifi_state = state_data.get("Wifi") or {}
    power_state = state_data.get("POWER")
    wifi_signal_dbm = wifi_state.get("Signal")

    name = _clean_str(device_info.get("name"))
    ip = _clean_str(device_info.get("ip"))
    mac = _clean_str(device_info.get("mac"))
    module = _clean_str(device_info.get("module"))
    version = _clean_str(device_info.get("version"))
    uptime = _clean_str(device_info.get("uptime"))
    wifi_ssid = _clean_str(device_info.get("wifi_ssid"))
    wifi_rssi = _clean_str(device_info.get("wifi_rssi"))

    print(f"\n‚îå{'‚îÄ' * 60}‚îê")
    print(f"‚îÇ üè† {name:<56} ‚îÇ")
    print(f"‚îú{'‚îÄ' * 60}‚î§")
    print(f"‚îÇ üåê IP address:     {ip:<41} ‚îÇ")
    print(f"‚îÇ MAC address:      {mac:<41} ‚îÇ")
    print(f"‚îÇ üì± Module:         {module:<41} ‚îÇ")
    print(f"‚îÇ üîÑ Version:        {version:<41} ‚îÇ")
    print(f"‚îÇ ‚è±Ô∏è  Uptime:         {uptime:<41} ‚îÇ")
    if power_state:
        print(f"‚îÇ üîå POWER:          {str(power_state):<41} ‚îÇ")
    print(f"‚îÇ üì∂ WiFi SSID:      {wifi_ssid:<41} ‚îÇ")
    print(f"‚îÇ üìä WiFi RSSI:      {wifi_rssi} dBm{'':<37} ‚îÇ")
    if wifi_signal_dbm is not None:
        print(f"‚îÇ üì° Signal (State): {str(wifi_signal_dbm):<41} ‚îÇ")
    print(f"‚îú{'‚îÄ' * 60}‚î§")

    if energy_data['total'] != 'N/A':
        kosten_total = float(energy_data['total']) * preis_prokw if energy_data['total'] != 'N/A' else 0
        kosten_today = float(energy_data['today']) * preis_prokw if energy_data['today'] != 'N/A' else 0
        kosten_yesterday = float(energy_data['yesterday']) * preis_prokw if energy_data['yesterday'] != 'N/A' else 0

        print(f"‚îÇ ‚ö° Current power:   {energy_data['power']} W{'':<35} ‚îÇ")
        print(f"‚îÇ üîå Voltage:        {energy_data['voltage']} V{'':<35} ‚îÇ")
        print(f"‚îÇ ‚ö° Current:        {energy_data['current']} A{'':<35} ‚îÇ")
        print(f"‚îÇ üìà Today:          {energy_data['today']} kWh - {kosten_today:.2f} EUR{'':<22} ‚îÇ")
        print(f"‚îÇ üìä Yesterday:      {energy_data['yesterday']} kWh - {kosten_yesterday:.2f} EUR{'':<22} ‚îÇ")
        print(f"‚îÇ üí∞ Total:          {energy_data['total']} kWh - {kosten_total:.2f} EUR{'':<22} ‚îÇ")
        print(f"‚îî{'‚îÄ' * 60}‚îò")
        return kosten_total
    else:
        print(f"‚îÇ ‚ö†Ô∏è  Energy data:     Not available{'':<30} ‚îÇ")
        print(f"‚îî{'‚îÄ' * 60}‚îò")
        return 0

def scan_network(plot: bool = True):
    print("üîç Starting network scan for Tasmota devices...")
    network_prefix = get_local_network()
    possible_ips = [f"{network_prefix}{i}" for i in range(1, 255)]

    tasmota_devices = []
    total_kosten = 0
    with ThreadPoolExecutor(max_workers=20) as executor:
        results = executor.map(check_tasmota, possible_ips)
        tasmota_devices = [ip for ip in results if ip]

    if tasmota_devices:
        print(f"\nüéØ Found {len(tasmota_devices)} Tasmota device(s):")
        print("=" * 70)

        devices_for_ui = []
        device_count = 0
        for device in tasmota_devices:
            device_count += 1
            print(f"\nüì± Device {device_count} of {len(tasmota_devices)}:")

            try:
                device_info = get_device_info(device)
                state_data = get_state_data(device)
                energy_data = get_energy_data(device)
                kosten = print_device_details(device_info, energy_data, state_data=state_data)
                total_kosten += kosten

                hostname = state_data.get("Hostname") or device_info.get("name")
                mac = _normalize_mac(device_info.get("mac"))
                stem = _safe_filename(hostname, fallback=(mac or device_info.get("ip") or "device"))

                # If two devices share a hostname, disambiguate by MAC.
                filename = f"{stem}.json"
                if mac and stem.upper() == mac.upper().replace(":", ""):
                    filename = f"{stem}.json"
                elif mac:
                    filename = f"{stem}__{mac.replace(':', '')}.json"

                device_log_path = DATA_DIR / filename
                device_log = load_device_log(device_log_path)
                log_device_snapshot(device_log, device_info, energy_data, preis_prokw=0.329, state_data=state_data)
                save_device_log(device_log_path, device_log)

                devices_for_ui.append({
                    "ip": device_info.get("ip"),
                    "hostname": state_data.get("Hostname") or device_info.get("name"),
                })
            except Exception as exc:
                print(f"‚ö†Ô∏è  Error while querying {device}: {exc}")
                continue

        # Update the hardcoded web UI so it matches the scan result.
        try:
            devices_for_ui = [d for d in devices_for_ui if d.get("ip")]
            devices_for_ui.sort(key=lambda d: str(d.get("hostname") or ""))
            _rewrite_switch_control_html(devices_for_ui, SWITCH_CONTROL_HTML)
        except Exception:
            pass

        print(f"\n{'=' * 70}")
        print(f"üí∏ TOTAL COST (all devices): {total_kosten:.2f} EUR")
        print(f"üìä Device count: {len(tasmota_devices)}")
        if len(tasmota_devices) > 0:
            print(f"üí° Average cost per device: {total_kosten/len(tasmota_devices):.2f} EUR")
        print(f"üíæ Logs saved in: {DATA_DIR}")
        if plot:
            generate_cost_plot_per_device(DATA_DIR, Path(__file__).with_name("tasmota_cost_plot.png"))
        print("=" * 70)
    else:
        print("‚ùå No Tasmota devices found.")

if __name__ == "__main__":
    _ensure_utf8_stdout()
    print("üöÄ Tasmota Network Scanner started")
    print("üì° Scanning local network for Tasmota devices...\n")
    scan_network(plot=True)
    input("\n‚úÖ Scan finished!")
